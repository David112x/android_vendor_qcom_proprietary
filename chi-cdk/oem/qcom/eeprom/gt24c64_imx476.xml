<?xml version="1.0" encoding="utf-8" ?>
<!--
========================================================================
   Copyright(c) 2018 Qualcomm Technologies, Inc.
   All Rights Reserved.
   Confidential and Proprietary - Qualcomm Technologies, Inc.
========================================================================
-->
<EEPROMDriverData
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:noNamespaceSchemaLocation="../../../api/sensor/camxeepromdriver.xsd">
  <module_version major_revision="1" minor_revision="0" incr_revision="0"/>
  <!--EEPROM slave information
       element for EEPROMName
       element for slaveAddress
       elemet for regAddrType
       element for regDataType
       element for I2CFrequencyMode
       element for power up sequence
       element for power down sequence  -->
  <!--  description="EEPROM Slave Information" length="" -->
  <slaveInfo description="EEPROM Slave Information" length="">
    <!--Name of the EEPROM device -->
    <EEPROMName>gt24c64_imx476</EEPROMName>
    <!--8-bit or 10-bit I2C slave Write address -->
    <slaveAddress>0xa0</slaveAddress>
    <!--Register address / data size in bytes -->
    <!--  range="[1,4]" length="" -->
    <regAddrType range="[1,4]" length="">2</regAddrType>
    <!--Register address / data size in bytes -->
    <!--  range="[1,4]" length="" -->
    <regDataType range="[1,4]" length="">1</regDataType>
    <!--I2C frequency mode of slave
        Supported modes are: STANDARD (100 KHz), FAST (400 KHz), FAST_PLUS (1 MHz), CUSTOM (Custom frequency in DTSI) -->
    <i2cFrequencyMode>FAST</i2cFrequencyMode>
    <!--Sequence of power configuration type and configuration value required to control power to the device -->
    <powerUpSequence>
      <!--Power setting configuration
          Contains: configType, configValue and delay in milli seconds -->
      <powerSetting>
        <!--Power configuration type
            Supported types are: MCLK, VANA, VDIG, VIO, VAF, RESET, STANDBY -->
        <configType>VIO</configType>
        <!--Configuration value for the type of configuration -->
        <configValue>0</configValue>
        <!--Delay in milli seconds -->
        <delayMs>0</delayMs>
      </powerSetting>
    </powerUpSequence>
    <!--Sequence of power configuration type and configuration value required to control power to the device -->
    <powerDownSequence>
      <!--Power setting configuration
          Contains: configType, configValue and delay in milli seconds -->
      <powerSetting>
        <!--Power configuration type
            Supported types are: MCLK, VANA, VDIG, VIO, VAF, RESET, STANDBY -->
        <configType>VIO</configType>
        <!--Configuration value for the type of configuration -->
        <configValue>0</configValue>
        <!--Delay in milli seconds -->
        <delayMs>0</delayMs>
      </powerSetting>
    </powerDownSequence>
  </slaveInfo>
  <!--Sequence of register settings to configure the device -->
  <memoryMap>
    <!--Register setting configuration
        Contains: register address, register data, register address type, register data type,
        operation and delay in micro seconds
         element for slaveAddr
         element for registerAddr
         element for registerData
         element for regAddrType
         element for regDataType
         element for operation
         element for delayUs  -->
    <regSetting>
      <!--Register address that is accessed -->
      <registerAddr>0x0</registerAddr>
      <!--List of data items in bytes seperated by space as delimiter.
          Data may be written to an I2C slave in burst mode.
          If operation is WRITE, a single registerData item is to be written into location specified by registerAddr.
          For operation WRITE_BURST, a list of 1 or more registerData items will be written serially starting
          at the location specified by registerAddr, and the I2C slave will internally increment the address for each
          registerData item.
          For operation WRITE_SEQUENTIAL, a list of 1 or more registerData items will be written serially starting
          at the location specified by registerAddr, but the address is explicitly generated by the driver for each
          registerData item in the list.
          If operation is READ, registerData is the number of bytes to be read from the specified register address -->
      <registerData>1800</registerData>
      <!--Register address / data size in bytes -->
      <!--  range="[1,4]" length="" -->
      <regAddrType range="[1,4]" length="">2</regAddrType>
      <!--Register address / data size in bytes -->
      <!--  range="[1,4]" length="" -->
      <regDataType range="[1,4]" length="">1</regDataType>
      <!--Type of I2C operation
          Valid values are: WRITE, WRITE_BURST, WRITE_SEQUENTIAL, READ, POLL -->
      <operation>READ</operation>
    </regSetting>
  </memoryMap>
  <!--EEPROM data format information
       element for auto focus information
       element for white balance information
       element for lens shading information
       element for dual camera information
       element for shield pixel information
       element for OIS calibration information
       element for PDAF DCC information
       element for pdaf 2D information  -->
  <!--  description="EEPROM Data Format Information" length="" -->
  <formatInfo description="EEPROM Data Format Information" length="">
    <!--Specifies white balance data information to format the OTP data
         element for WB data availablity and endian
         element for WBType information
         element for WB light information
         element for mirror information
         element for flip information
         element for qValue information
         element for isInvertGROverGB information  -->
    <WB>
      <!--Specifies the availability of the specified data and type of endianness
           element for operation  -->
      <!--  description="Memory Type" length="" -->
      <WBData description="Memory Type" length="">
        <!--Specifies whether a particular OTP data available or not -->
        <isAvailable>true</isAvailable>
        <!--Type of the Endianness
            Valid values are: BIG, LITTLE -->
        <endianness>LITTLE</endianness>
      </WBData>
      <!--Type of the white balance data
          Valid values are: INDIVIDUAL, RATIO -->
      <datatype>RATIO</datatype>
      <!--whitebalance information for a particular light type
           element for light type
           element for R value information
           element for gr Value information
           element for b Value information
           element for gb Value information
           element for rOverG Value information
           element for bOverG Value information
           element for grOverGB Value information  -->
      <!--  description="White balance light Information" length="" -->
      <lightInfo description="White balance light Information" length="">
        <!--Type of the illuminant
            Supported illuminants are D65, TL84, A, D50 and H -->
        <illuminantType>D65</illuminantType>
        <!--Specifies memory offset value and mask information -->
        <rValue>
          <!--Offset value in the OTP memory -->
          <offset>0</offset>
          <!--mask value which will be applied to obtain required data bits -->
          <mask>0</mask>
        </rValue>
        <!--Specifies memory offset value and mask information -->
        <grValue>
          <!--Offset value in the OTP memory -->
          <offset>0</offset>
          <!--mask value which will be applied to obtain required data bits -->
          <mask>0</mask>
        </grValue>
        <!--Specifies memory offset value and mask information -->
        <bValue>
          <!--Offset value in the OTP memory -->
          <offset>0</offset>
          <!--mask value which will be applied to obtain required data bits -->
          <mask>0</mask>
        </bValue>
        <!--Specifies memory offset value and mask information -->
        <gbValue>
          <!--Offset value in the OTP memory -->
          <offset>0</offset>
          <!--mask value which will be applied to obtain required data bits -->
          <mask>0</mask>
        </gbValue>
        <!--Specifies memory offset value and mask information -->
        <rOverGValue>
          <!--Offset value in the OTP memory -->
          <offset>0x16</offset>
          <!--mask value which will be applied to obtain required data bits -->
          <mask>0xFFFF</mask>
        </rOverGValue>
        <!--Specifies memory offset value and mask information -->
        <bOverGValue>
          <!--Offset value in the OTP memory -->
          <offset>0x18</offset>
          <!--mask value which will be applied to obtain required data bits -->
          <mask>0xFFFF</mask>
        </bOverGValue>
        <!--Specifies memory offset value and mask information -->
        <grOverGBValue>
          <!--Offset value in the OTP memory -->
          <offset>0x1A</offset>
          <!--mask value which will be applied to obtain required data bits -->
          <mask>0xFFFF</mask>
        </grOverGBValue>
      </lightInfo>
      <!--Specifies memory offset value and mask information -->
      <mirror>
        <!--Offset value in the OTP memory -->
        <offset>0</offset>
        <!--mask value which will be applied to obtain required data bits -->
        <mask>0</mask>
      </mirror>
      <!--Specifies memory offset value and mask information -->
      <flip>
        <!--Offset value in the OTP memory -->
        <offset>0</offset>
        <!--mask value which will be applied to obtain required data bits -->
        <mask>0</mask>
      </flip>
      <!--Q value -->
      <qValue>1024.0</qValue>
      <!--Set to TRUE if GRoverGB needs to be inverted -->
      <isInvertGROverGB>false</isInvertGROverGB>
    </WB>
    <!--Specifies LSC data information to format the OTP data
         element for LSC data availablity and endian
         element for LSC light information
         element for mesh HW roll off size information
         element for incrimenting value for obtaing R value information
         element for incrimenting value for obtaing GR value information
         element for incrimenting value for obtaing GB value information
         element for incrimenting value for obtaing B value information  -->
    <LSC>
      <!--Specifies the availability of the specified data and type of endianness
           element for operation  -->
      <!--  description="Memory Type" length="" -->
      <LSCData description="Memory Type" length="">
        <!--Specifies whether a particular OTP data available or not -->
        <isAvailable>true</isAvailable>
        <!--Type of the Endianness
            Valid values are: BIG, LITTLE -->
        <endianness>LITTLE</endianness>
      </LSCData>
      <!--Lens shading information for a particular rolloff light
           element for light type
           element for MSB part of the R gain value information
           element for LSB part of the R gain value information
           element for MSB part of the gr gain value information
           element for LSB part of the gr gain value information
           element for MSB part of the gb gain value information
           element for LSB part of the gb gain value information
           element for MSB part of the b gain value information
           element for LSB part of the b gain value information  -->
      <!--  description="Lens shading light information" length="" -->
      <lightInfo description="Lens shading light information" length="">
        <!--Type of the illuminant
            Supported illuminants are D65, TL84, A, D50 and H -->
        <illuminantType>D65</illuminantType>
        <!--Specifies memory offset value and mask information -->
        <rGainMSB>
          <!--Offset value in the OTP memory -->
          <offset>33</offset>
          <!--mask value which will be applied to obtain required data bits -->
          <mask>0xFF</mask>
        </rGainMSB>
        <!--Specifies memory offset value and mask information -->
        <rGainLSB>
          <!--Offset value in the OTP memory -->
          <offset>32</offset>
          <!--mask value which will be applied to obtain required data bits -->
          <mask>0xFF</mask>
        </rGainLSB>
        <!--Specifies memory offset value and mask information -->
        <grGainMSB>
          <!--Offset value in the OTP memory -->
          <offset>475</offset>
          <!--mask value which will be applied to obtain required data bits -->
          <mask>0xFF</mask>
        </grGainMSB>
        <!--Specifies memory offset value and mask information -->
        <grGainLSB>
          <!--Offset value in the OTP memory -->
          <offset>474</offset>
          <!--mask value which will be applied to obtain required data bits -->
          <mask>0xFF</mask>
        </grGainLSB>
        <!--Specifies memory offset value and mask information -->
        <gbGainMSB>
          <!--Offset value in the OTP memory -->
          <offset>917</offset>
          <!--mask value which will be applied to obtain required data bits -->
          <mask>0xFF</mask>
        </gbGainMSB>
        <!--Specifies memory offset value and mask information -->
        <gbGainLSB>
          <!--Offset value in the OTP memory -->
          <offset>916</offset>
          <!--mask value which will be applied to obtain required data bits -->
          <mask>0xFF</mask>
        </gbGainLSB>
        <!--Specifies memory offset value and mask information -->
        <bGainMSB>
          <!--Offset value in the OTP memory -->
          <offset>1359</offset>
          <!--mask value which will be applied to obtain required data bits -->
          <mask>0xFF</mask>
        </bGainMSB>
        <!--Specifies memory offset value and mask information -->
        <bGainLSB>
          <!--Offset value in the OTP memory -->
          <offset>1358</offset>
          <!--mask value which will be applied to obtain required data bits -->
          <mask>0xFF</mask>
        </bGainLSB>
      </lightInfo>
      <!--mesh HW rolloff size -->
      <meshHWRollOffSize>221</meshHWRollOffSize>
      <!--position of the next R value from the current R -->
      <rIncrement>2</rIncrement>
      <!--position of the next GR value from the current GR -->
      <grIncrement>2</grIncrement>
      <!--position of the next GB value from the current GB -->
      <gbIncrement>2</gbIncrement>
      <!--position of the next B value from the current B -->
      <bIncrement>2</bIncrement>
    </LSC>
  </formatInfo>
</EEPROMDriverData>
