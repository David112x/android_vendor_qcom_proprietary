<?xml version="1.0" encoding="UTF-8"?>
<!--========================================================================-->
<!-- Copyright (c) 2016-2019 Qualcomm Technologies, Inc.                    -->
<!-- All Rights Reserved.                                                   -->
<!-- Confidential and Proprietary - Qualcomm Technologies, Inc.             -->
<!--========================================================================-->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:include schemaLocation="camxsensorcommon.xsd"/>

    <xs:complexType name="SlaveInformation">
        <xs:annotation>
            <xs:documentation>Sensor slave information</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <!-- element for sensorName -->
            <xs:element name="sensorName" type="xs:string">
                <xs:annotation>
                    <xs:documentation>Name of the sensor</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for slaveAddress -->
            <xs:element name="slaveAddress" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>8-bit or 10-bit write slave address</xs:documentation>
                    <xs:documentation>For External Sensors for which camx needs not probe the slave address shoule be as 0</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for regAddrType -->
            <xs:element name="regAddrType" type="I2CRegAddrDataType"/>

            <!-- element for regDataType -->
            <xs:element name="regDataType" type="I2CRegAddrDataType"/>

            <!-- element for sensorIdRegAddr -->
            <xs:element name="sensorIdRegAddr" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>Register address for sensor Id</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for sensorId -->
            <xs:element name="sensorId" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>Sensor Id</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for sensorIdMask -->
            <xs:element name="sensorIdMask" type="xs:unsignedInt" default="4294967295">
                <xs:annotation>
                    <xs:documentation>Mask for sensor id. Sensor Id may only be few bits</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for i2cFrequencyMode -->
            <xs:element name="i2cFrequencyMode" type="I2CFrequencyMode" default="FAST_PLUS" />

            <!-- element for powerUpSequence -->
            <xs:element name="powerUpSequence" type="PowerSequenceInfo" />

            <!-- element for powerDownSequence -->
            <xs:element name="powerDownSequence" type="PowerSequenceInfo" />
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="RegAddrInformation">
        <xs:annotation>
            <xs:documentation>Addresses for various sensor registers</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <!-- element for xOutput -->
            <xs:element name="xOutput" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>Register address to program width</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for yOutput -->
            <xs:element name="yOutput" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>Register address to program height</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for frameLengthLines -->
            <xs:element name="frameLengthLines" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>Register address to program Frame length lines</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for lineLengthPixelClock -->
            <xs:element name="lineLengthPixelClock" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>Register address to program Line length pixel clock</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for coarseIntgTimeAddr -->
            <xs:element name="coarseIntgTimeAddr" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>Register address to program coarse integration time</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for shortCoarseIntgTimeAddr -->
            <xs:element name="shortCoarseIntgTimeAddr" type="xs:unsignedInt" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Register address to program short coarse integration time</xs:documentation>
                    <xs:documentation>This address is optional and must be provided if supported by sensor</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for analog globalGainAddr -->
            <xs:element name="globalGainAddr" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>Register address to program analog global gain channel</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for analog shortGlobalGainAddr -->
            <xs:element name="shortGlobalGainAddr" type="xs:unsignedInt" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Register address to program short global analog gain channel</xs:documentation>
                    <xs:documentation>This address is optional and must be provided if supported by sensor</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for digitalGlobalGainAddr -->
            <xs:element name="digitalGlobalGainAddr" type="xs:unsignedInt" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Register address to program digital gloabl gain channel</xs:documentation>
                    <xs:documentation>This address is optional and must be provided if supported by sensor</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for digitalGainRedAddr -->
            <xs:element name="digitalGainRedAddr" type="xs:unsignedInt" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Register address to program digital gain for Red channel</xs:documentation>
                    <xs:documentation>This address is optional and must be provided if supported by sensor</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for digitalGainGreenRedAddr -->
            <xs:element name="digitalGainGreenRedAddr" type="xs:unsignedInt" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Register address to program digital gain for green red channel</xs:documentation>
                    <xs:documentation>This address is optional and must be provided if supported by sensor</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for digitalGainBlueAddr -->
            <xs:element name="digitalGainBlueAddr" type="xs:unsignedInt" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Register address to program digital gain for blue channel</xs:documentation>
                    <xs:documentation>This address is optional and must be provided if supported by sensor</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for digitalGainGreenBlueAddr -->
            <xs:element name="digitalGainGreenBlueAddr" type="xs:unsignedInt" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Register address to program digital gain for green blue channel</xs:documentation>
                    <xs:documentation>This address is optional and must be provided if supported by sensor</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for testPatternRAddr -->
            <xs:element name="testPatternRAddr" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>Register address to program manual test pattern value for Red channel</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for testPatternGRAddr -->
            <xs:element name="testPatternGRAddr" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>Register address to program manual test pattern value for Green Red channel</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for testPatternBAddr -->
            <xs:element name="testPatternBAddr" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>Register address to program manual test pattern value for Blue channel</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for testPatternGBAddr -->
            <xs:element name="testPatternGBAddr" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>Register address to program manual test pattern value for Green Blue channel</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:complexType>

    <xs:simpleType name="ColorFilterArrangement">
        <xs:annotation>
            <xs:documentation>Color filter arrangement of the sensor</xs:documentation>
            <xs:documentation>Supported filter arrangements are: BAYER_BGGR, BAYER_GBRG, BAYER_GRBG, BAYER_RGGB, BAYER_Y, YUV_UYVY, YUV_YUYV</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="BAYER_BGGR"/>
            <xs:enumeration value="BAYER_GBRG"/>
            <xs:enumeration value="BAYER_GRBG"/>
            <xs:enumeration value="BAYER_RGGB"/>
            <xs:enumeration value="BAYER_Y"/>
            <xs:enumeration value="YUV_UYVY"/>
            <xs:enumeration value="YUV_YUYV"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="DelayInfoType">
        <xs:annotation>
            <xs:documentation>Indicates for which category the delay Info belongs to</xs:documentation>
            <xs:documentation>Supported types are ExposureControl, Framesync. Framesync delay info is used for multi camera synchronization</xs:documentation>
            <xs:documentation>For all exposure control purposes ExposureControl type is used including the maxpipeline delay</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="EXPOSURECONTROL"/>
            <xs:enumeration value="FRAMESYNC"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="VirtualChannel">
        <xs:annotation>
            <xs:documentation>Virtual Channel of the data</xs:documentation>
            <xs:documentation>Valid values for virtual channel are: 0, 1, 2 and 3</xs:documentation>
        </xs:annotation>
        <xs:simpleContent>
            <xs:extension base="xs:unsignedInt">
                <xs:attribute name="range" type="xs:string" default="[0,3]"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

  <xs:complexType name="IntegrationInfo">
    <xs:annotation>
      <xs:documentation>Integration related information for each resolution</xs:documentation>
    </xs:annotation>
    <xs:sequence>

      <!-- element for integrationTimeMin -->
      <xs:element name="integrationTimeMin" type="xs:unsignedInt" default="0">
        <xs:annotation>
          <xs:documentation>Minimum integration time</xs:documentation>
        </xs:annotation>
      </xs:element>

      <!-- element for integrationTimeStep -->
      <xs:element name="integrationTimeStep" type="xs:unsignedInt" default="0">
        <xs:annotation>
          <xs:documentation>The step of integration time</xs:documentation>
        </xs:annotation>
      </xs:element>

      <!-- element for integrationTimeMargin -->
      <xs:element name="integrationTimeMargin" type="xs:unsignedInt" default="0">
        <xs:annotation>
          <xs:documentation>Integration time margin</xs:documentation>
        </xs:annotation>
      </xs:element>

    </xs:sequence>
</xs:complexType>

    <xs:simpleType name="StreamType">
        <xs:annotation>
            <xs:documentation>Type of the stream</xs:documentation>
            <xs:documentation>Supported stream types are: BLOB, IMAGE, PDAF, HDR, META</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="BLOB"/>
            <xs:enumeration value="IMAGE"/>
            <xs:enumeration value="PDAF"/>
            <xs:enumeration value="HDR"/>
            <xs:enumeration value="META"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="StreamConfiguration">
        <xs:annotation>
            <xs:documentation>Information for a stream data</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <!-- element for vc -->
            <xs:element name="vc" type="VirtualChannel" default="0" />

            <!-- element for dt -->
            <xs:element name="dt" type="xs:unsignedInt" default="0x2B">
                <xs:annotation>
                    <xs:documentation>Data type of the stream. Default value is 0x2B (10-bit RAW)</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for dimension -->
            <xs:element name="frameDimension" type="FrameDimension" />

            <!-- element for bitWidth -->
            <xs:element name="bitWidth" type="xs:unsignedInt" default="10">
                <xs:annotation>
                    <xs:documentation>Bit width of the data</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for type -->
            <xs:element name="type" type="StreamType" default="IMAGE" />
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="StreamInformation">
        <xs:annotation>
            <xs:documentation>Stream information</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="streamConfiguration" type="StreamConfiguration" maxOccurs="4" />
        </xs:sequence>
    </xs:complexType>

    <xs:simpleType name="SensorCapability">
        <xs:annotation>
            <xs:documentation>Capability / features supported in sensor</xs:documentation>
            <xs:documentation>Supported features are: NORMAL, HFR, IHDR, PDAF, QUADCFA, ZZHDR, FASTAEC, DEPTH, SHDR, FS, INTERNAL</xs:documentation>
            <xs:documentation>FS, typically, is a full size 120 fps mode and it's purpose is different from HFR</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="NORMAL"/>
            <xs:enumeration value="HFR"/>
            <xs:enumeration value="IHDR"/>
            <xs:enumeration value="PDAF"/>
            <xs:enumeration value="QUADCFA"/>
            <xs:enumeration value="ZZHDR"/>
            <xs:enumeration value="FASTAEC"/>
            <xs:enumeration value="DEPTH"/>
            <xs:enumeration value="SHDR"/>
            <xs:enumeration value="FS"/>
            <xs:enumeration value="INTERNAL"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="SensorCapabilityList">
        <xs:annotation>
            <xs:documentation>List of features / capabilities supported by sensor</xs:documentation>
        </xs:annotation>
        <xs:list itemType="SensorCapability"/>
    </xs:simpleType>

    <xs:simpleType name="MipiFlagsType">
        <xs:annotation>
            <xs:documentation>Mipi flags that receiver needs to take care</xs:documentation>
            <xs:documentation>Supported flags are: EPDEnabled, DSKEWCalibEnabled</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="EPDEnabled"/>
            <xs:enumeration value="DSKEWCalibEnabled"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="MipiFlagsList">
        <xs:annotation>
            <xs:documentation>List of Mipi flags that Mipi recever needs to take care of</xs:documentation>
        </xs:annotation>
        <xs:list itemType="MipiFlagsType"/>
    </xs:simpleType>


    <xs:simpleType name="HDR3ExposureTypeInfo">
        <xs:annotation>
            <xs:documentation>This value represents 3-Exposure HDR sensor type</xs:documentation>
            <xs:documentation>It indicates what types of sensor statistcs data output under 3-Exposure HDR mode</xs:documentation>
            <xs:documentation>HDR3ExposureType1: split, merged statistics data</xs:documentation>
            <xs:documentation>HDR3ExposureType2: split, merged and grid statistics data</xs:documentation>
            <xs:documentation>HDR3ExposureType3: split, merged and ROI related statistics data</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="HDR3ExposureTypeUnknown"/>
            <xs:enumeration value="HDR3ExposureType1"/>
            <xs:enumeration value="HDR3ExposureType2"/>
            <xs:enumeration value="HDR3ExposureType3"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="ZZHDRFirstExposurePattern">
        <xs:annotation>
            <xs:documentation>This value represents whether short exposure or long exposure field comes first</xs:documentation>
            <xs:documentation>for the red or blue color pixel in the pattern.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="SHORTEXPOSURE"/>
            <xs:enumeration value="LONGEXPOSURE"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="ZZHDRColorPattern">
        <xs:annotation>
            <xs:documentation>This value represents the zzHDR pattern.</xs:documentation>
            <xs:documentation>Valid patterns are: P0P1P0P0, P0P1P0P1, P0P0P1P0, P0P0P1P1, P0P0P0P1, P0P1P1P1, P0P1P1P0</xs:documentation>
            <xs:documentation>Each pattern bit(P0 and P1) represents either long or short</xs:documentation>
            <xs:documentation>exposure repeating pattern.</xs:documentation>
            <xs:documentation>First bit of pattern would be interpreted based on ZZHDRFirstExposurePattern.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="P0P1P0P0"/>
            <xs:enumeration value="P0P1P0P1"/>
            <xs:enumeration value="P0P0P1P0"/>
            <xs:enumeration value="P0P0P1P1"/>
            <xs:enumeration value="P0P0P0P1"/>
            <xs:enumeration value="P0P1P1P1"/>
            <xs:enumeration value="P0P1P1P0"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="BorderInformation">
        <xs:sequence>
            <xs:element name="left" type="xs:unsignedInt" default="0" />
            <xs:element name="right" type="xs:unsignedInt" default="0" />
            <xs:element name="top" type="xs:unsignedInt" default="0" />
            <xs:element name="bottom" type="xs:unsignedInt" default="0" />
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="ResolutionData">
        <xs:sequence>
            <!-- element for colorFilterArrangement -->
            <xs:element name="colorFilterArrangement" type="ColorFilterArrangement" />

            <!-- element for streamInfo -->
            <xs:element name="streamInfo" type="StreamInformation"/>

            <!-- element for lineLengthPixelClock -->
            <xs:element name="lineLengthPixelClock" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>Line length pixel clock of frame</xs:documentation>
                    <xs:documentation>Typically this value is the active width + blanking width</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for frameLengthLines -->
            <xs:element name="frameLengthLines" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>Frame length lines of frame</xs:documentation>
                    <xs:documentation>Typically this value is the active height + blanking height</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for minHorizontalBlanking -->
            <xs:element name="minHorizontalBlanking" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>Minimum horizontal blanking interval in pixels</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for minVerticalBlanking -->
            <xs:element name="minVerticalBlanking" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>Minimum horizontal blanking interval in lines</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for outputPixelClock -->
            <xs:element name="outputPixelClock" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>Output pixel clock</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for horizontalBinning -->
            <xs:element name="horizontalBinning" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>Horizontal binning value</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for verticalBinning -->
            <xs:element name="verticalBinning" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>Vertical binning value</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for frameRate -->
            <xs:element name="frameRate" type="xs:double">
                <xs:annotation>
                    <xs:documentation>Maximum frame rate</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for laneCount -->
            <xs:element name="laneCount" type="xs:unsignedInt" default="4">
                <xs:annotation>
                    <xs:documentation>Number of lanes in which the data is streamed</xs:documentation>
                </xs:annotation>
            </xs:element>

          <!-- element for downScaleFactor -->
          <xs:element name="downScaleFactor" type="xs:Float" default="1.0" minInclusive="1.0" minOccurs="0" >
            <xs:annotation>
              <xs:documentation>The value is a ratio, and the sensors are able only to downscale.</xs:documentation>
              <xs:documentation>It must be 1.00 or greater at all times.</xs:documentation>
            </xs:annotation>
          </xs:element>

            <!-- element for settleTimeNs -->
            <xs:element name="settleTimeNs" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>Settle time in nano seconds</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for is3Phase -->
            <xs:element name="is3Phase" type="xs:unsignedInt" default="0">
                <xs:annotation>
                    <xs:documentation>Flag to know if the sensor is a 3phase sensor</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for integrationInfo -->
            <xs:element name="integrationInfo" type="IntegrationInfo" minOccurs="0" />

            <!-- element for resSettings -->
            <xs:element name="resSettings" type="SettingsInfo" />

            <!-- element for cropInfo -->
            <xs:element name="cropInfo" type="BorderInformation">
                <xs:annotation>
                    <xs:documentation>Crop information for the frame</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for ZZHDR Information -->
            <xs:element name="ZZHDRInfo" type="ZZHDRInformation" minOccurs="0"/>

            <!-- element for 3-Exposure HDR Information -->
            <xs:element name="HDR3ExposureInfo" type="HDR3ExposureInformation" minOccurs="0"/>

            <!-- element for RemosaicType Information -->
            <xs:element name="RemosaicTypeInfo" type="RemosaicType" minOccurs="0"/>

            <!-- element for capability -->
            <xs:element name="capability" type="SensorCapabilityList" />

            <!-- element for ADCReadoutTime -->
            <xs:element name="ADCReadoutTime" type="xs:double" default="0" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Analog to digital conversion time for the sensor. Time specified in milliseconds</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for MipiFlags-->
            <xs:element name="mipiFlags" type="MipiFlagsList" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Any extra mipi parameters that recevier should take care of</xs:documentation>
                    <xs:documentation>EPDEnabled, DSKEWCalibEnabled</xs:documentation>
                </xs:annotation>
            </xs:element>

        </xs:sequence>
    </xs:complexType>

    <xs:simpleType name="RemosaicType">
        <xs:annotation>
            <xs:documentation>This value represents Remosaic Type.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="SWRemosaic"/>
            <xs:enumeration value="HWRemosaic"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="HDR3ExposureInformation">
        <xs:annotation>
            <xs:documentation>Information of in-sensor HDR 3 exposure</xs:documentation>
            <xs:documentation>HDR3ExposureType: exposure type for 3HDR non-seamless mode</xs:documentation>
            <xs:documentation>numberOfLTCRatioRegCount: Number of LTC ratio registers</xs:documentation>
            <xs:documentation>sensorLTCRatioAddr : Register address to program LTC ratio</xs:documentation>
            <xs:documentation>InSensorHDR3ExpLineLengthPixelClock: LineLengthPixelClock for seamless in-sensor HDR 3 exp mode switching</xs:documentation>
            <xs:documentation>InSensorHDR3ExpFrameLengthLines: FrameLengthLines for seamless in-sensor HDR 3 exp mode switching</xs:documentation>
            <xs:documentation>InSensorHDR3ExpMaxAnalogGain: MaxAnalogGain for seamless in-sensor HDR 3 exp mode switching</xs:documentation>
            <xs:documentation>InSensorHDR3ExpStartSettings: StartSetting sequence for seamless in-sensor HDR 3 exp mode switching</xs:documentation>
            <xs:documentation>InSensorHDR3ExpStopSettings: StopSetting sequence for seamless in-sensor HDR 3 exp mode switching</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="HDR3ExposureType"                     type="HDR3ExposureTypeInfo" default="0" minOccurs="0"/>
            <xs:element name="sensorLTCRatioAddr"                   type="xs:unsignedInt"       minOccurs="0"/>
            <xs:element name="numberOfLTCRatioRegCount"             type="xs:unsignedInt"       minOccurs="0"/>
            <xs:element name="InSensorHDR3ExpLineLengthPixelClock"  type="xs:unsignedInt"       minOccurs="0"/>
            <xs:element name="InSensorHDR3ExpFrameLengthLines"      type="xs:unsignedInt"       minOccurs="0"/>
            <xs:element name="InSensorHDR3ExpMaxAnalogGain"         type="xs:double"            minOccurs="0"/>
            <xs:element name="InSensorHDR3ExpStartSettings"         type="SettingsInfo"         minOccurs="0"/>
            <xs:element name="InSensorHDR3ExpStopSettings"          type="SettingsInfo"         minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="ZZHDRInformation">
        <xs:annotation>
            <xs:documentation>ZZHDR color pattern and first exposure information</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="ZZHDRPattern"       type="ZZHDRColorPattern"         minOccurs="0"/>
            <xs:element name="ZZHDRFirstExposure" type="ZZHDRFirstExposurePattern" minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="ResolutionInformation">
        <xs:annotation>
            <xs:documentation>Information of all the resolutions</xs:documentation>
            <xs:documentation>Number of resolutions is detected from number of resolutionData nodes</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="sensorVersion" type="xs:unsignedInt" default="0" minOccurs="0"/>
            <xs:element name="resolutionData" type="ResolutionData" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="InitSettings">
        <xs:annotation>
            <xs:documentation>Information of the initial settings</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="sensorVersion" type="xs:unsignedInt" default="0" />
            <xs:element name="initSetting" type="SettingsInfo"/>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="ExposureContorlInformation">
        <xs:annotation>
            <xs:documentation>Exposure control information</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <!-- element for maxAnalogGain -->
            <xs:element name="maxAnalogGain" type="xs:double">
                <xs:annotation>
                    <xs:documentation>Maximum analog again supported by sensor</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for maxDigitalGain -->
            <xs:element name="maxDigitalGain" type="xs:double">
                <xs:annotation>
                    <xs:documentation>Maximum digital again supported by sensor</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for minAnalogGain -->
            <xs:element name="minAnalogGain" type="xs:double" default="1.0" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Minimum analog again supported by sensor</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for verticalOffset -->
            <xs:element name="verticalOffset" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>Minimum offset to be maintained between line count and frame length lines</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for verticalOffset -->
            <xs:element name="multiCamLineDelta" type="xs:int" default="0" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Minimum number of lines of duration difference needed to synchronize master/slave</xs:documentation>
                    <xs:documentation>Will add/substract those many lines duration of corresponding sensor based on the value +ve/-ve </xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for maximum linecount -->
            <xs:element name="maxLineCount" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>Maximum line count supported by sensor</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for minimum linecount -->
            <xs:element name="minLineCount" type="xs:unsignedInt" default="1" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Minimum line count supported by sensor</xs:documentation>
                </xs:annotation>
            </xs:element>

             <!-- element for realToRegDigitalGainConversionFactor -->
            <xs:element name="realToRegDigitalGainConversionFactor" type="xs:double" default="256">
                <xs:annotation>
                    <xs:documentation>Conversion factor to convert real digital gain to register digital gain</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for analog realToRegGain -->
            <xs:element name="realToRegGain" type="xs:string" default="">
                <xs:annotation>
                    <xs:documentation>Real analog gain to register analog gain equation</xs:documentation>
                    <xs:documentation>The equation must contain "realGain" in its equation</xs:documentation>
                    <xs:documentation>Ex:= 512 - (512 / realGain)</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for analog regToRealGain -->
            <xs:element name="regToRealGain" type="xs:string" default="">
                <xs:annotation>
                    <xs:documentation>analog Register gain to real gain equation</xs:documentation>
                    <xs:documentation>The equation must contain "regGain" in its equation</xs:documentation>
                    <xs:documentation>Ex:= 512 / (512 - regGain)</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:complexType>

    <xs:simpleType name="TestPatternMode">
        <xs:annotation>
            <xs:documentation>Test pattern mode</xs:documentation>
            <xs:documentation>Supported modes are: OFF, SOLID_COLOR, COLOR_BARS, COLOR_BARS_FADE_TO_GRAY, PN9, CUSTOM1</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="OFF"/>
            <xs:enumeration value="SOLID_COLOR"/>
            <xs:enumeration value="COLOR_BARS"/>
            <xs:enumeration value="COLOR_BARS_FADE_TO_GRAY"/>
            <xs:enumeration value="PN9"/>
            <xs:enumeration value="CUSTOM1"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="TestPatternData">
        <xs:sequence>
            <xs:element name="mode" type="TestPatternMode" />
            <xs:element name="settings" type="SettingsInfo" />
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="TestPatternInformation">
        <xs:sequence>
            <xs:element name="testPatternData" type="TestPatternData" maxOccurs="unbounded" />
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="ColorLevelInformation">
        <xs:annotation>
            <xs:documentation>Color level information</xs:documentation>
            <xs:documentation>These are the default currents in various channels in complete dark light</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <!-- element for whiteLevel -->
            <xs:element name="whiteLevel" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>White level value</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for rPedestal -->
            <xs:element name="rPedestal" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>Pedestal value for Red channel</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for grPedestal -->
            <xs:element name="grPedestal" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>Pedestal value for GreenRed channel</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for bPedestal -->
            <xs:element name="bPedestal" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>Pedestal value for Blue channel</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for gbPedestal -->
            <xs:element name="gbPedestal" type="xs:unsignedInt">
                <xs:annotation>
                    <xs:documentation>Pedestal value for Green Blue channel</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="OpticalBlackRegionInfo">
        <xs:annotation>
            <xs:documentation>Information about black regions</xs:documentation>
            <xs:documentation>Multiple black regions can be provided if applicable</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="dimension" type="FrameDimension" maxOccurs="unbounded" />
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="PixelArrayInfo">
        <xs:annotation>
            <xs:documentation>Information about the pixel array</xs:documentation>
            <xs:documentation>Active dimension and dummy pixels width are provided</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="activeDimension" type="Dimension" />
            <xs:element name="dummyInfo" type="BorderInformation">
                <xs:annotation>
                    <xs:documentation>Dummy pixels surrounding the active pixel array</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="DelayInfo">
        <xs:annotation>
            <xs:documentation>Application delay information</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="delayType" type="DelayInfoType" default="EXPOSURECONTROL" minOccurs="0"/>
            <!-- element for linecount -->
            <xs:element name="linecount" type="xs:unsignedInt" default="0" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Number of frames required to apply the linecount</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for gain -->
            <xs:element name="gain" type="xs:unsignedInt" default="0" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Number of frames required to apply the gain</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for frame length lines -->
            <xs:element name="frameLengthLines" type="xs:unsignedInt" default="0" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Number of frames required to apply the frame length lines</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for maxPipelineDelay -->
            <xs:element name="maxPipeline" type="xs:unsignedInt" default="0">
                <xs:annotation>
                    <xs:documentation>Maximum pipeline delay in number of frames</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for frameSkip -->
            <xs:element name="frameSkip" type="xs:unsignedInt" default="0">
                <xs:annotation>
                    <xs:documentation>Number of initial bad frames to skip</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:complexType>

    <xs:simpleType name="SensingMethod">
        <xs:annotation>
            <xs:documentation>Sensing method of senosor</xs:documentation>
            <xs:documentation>Supported sensing methods: UNDEFINED, ONE_CHIP_COLOR_AREA, TWO_CHIP_COLOR_AREA</xs:documentation>
            <xs:documentation>THREE_CHIP_COLOR_AREA, COLOR_SEQUENCE_AREA, TRILINEAR, COLOR_SEQUENCE_LINEAR</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="UNDEFINED"/>
            <xs:enumeration value="ONE_CHIP_COLOR_AREA"/>
            <xs:enumeration value="TWO_CHIP_COLOR_AREA"/>
            <xs:enumeration value="THREE_CHIP_COLOR_AREA"/>
            <xs:enumeration value="COLOR_SEQUENCE_AREA"/>
            <xs:enumeration value="TRILINEAR"/>
            <xs:enumeration value="COLOR_SEQUENCE_LINEAR"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="SensorProperty">
        <xs:sequence>
            <!-- element for pixelSize -->
            <xs:element name="pixelSize" type="xs:double">
                <xs:annotation>
                    <xs:documentation>Pixel size in micro meters</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for cropFactor -->
            <xs:element name="cropFactor" type="xs:double">
                <xs:annotation>
                    <xs:documentation>Crop factor</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for sensingMethod -->
            <xs:element name="sensingMethod" type="SensingMethod" />
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="NoiseCoefficent">
        <xs:sequence>
            <!-- element for gradient_S -->
            <xs:element name="gradient_S" type="xs:double">
                <xs:annotation>
                    <xs:documentation>gradient_s Sensor amplification</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for offset_S -->
            <xs:element name="offset_S" type="xs:double">
                <xs:annotation>
                    <xs:documentation>offset_S Sensor amplification</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for gradient_O -->
            <xs:element name="gradient_O" type="xs:double">
                <xs:annotation>
                    <xs:documentation>gradient_O sensor readout noise</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- element for offset_O -->
            <xs:element name="offset_O" type="xs:double">
                <xs:annotation>
                    <xs:documentation>offset_O sensor readout noise</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:complexType>

    <xs:simpleType name="NoiseCoefficientChannel">
        <xs:annotation>
            <xs:documentation>Noise Coefficient Channels</xs:documentation>
            <xs:documentation>Channel are in R=0, GR=1, GB=2, B=3 order</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="BAYER_R"/>
            <xs:enumeration value="BAYER_Gr"/>
            <xs:enumeration value="BAYER_Gb"/>
            <xs:enumeration value="BAYER_B"/>
        </xs:restriction>
    </xs:simpleType>

    <!-- Noise Coefficient Channel need to match the Bayer CFA in RGGB order -->
    <xs:complexType name="NoiseCoefficientBayer">
        <xs:sequence>
            <xs:element name="R" type="NoiseCoefficent" />
            <xs:element name="Gr" type="NoiseCoefficent" />
            <xs:element name="Gb" type="NoiseCoefficent" />
            <xs:element name="B" type="NoiseCoefficent" />
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="EnumDefinition">
        <xs:sequence>
            <xs:element name="noiseCoefficientChannel" type="NoiseCoefficientChannel" minOccurs="0" />
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="SensorDriverData">
        <xs:sequence>
            <xs:element name="module_version">
                <xs:complexType>
                    <xs:attribute name="major_revision" type="xs:int" default="1"/>
                    <xs:attribute name="minor_revision" type="xs:int" default="0"/>
                    <xs:attribute name="incr_revision" type="xs:int" default="0"/>
                </xs:complexType>
            </xs:element>
            <xs:element name="slaveInfo" type="SlaveInformation" />
            <xs:element name="regAddrInfo" type="RegAddrInformation" />
            <xs:element name="resolutionInfo" type="ResolutionInformation" maxOccurs="unbounded" />
            <xs:element name="exposureControlInfo" type="ExposureContorlInformation" />
            <xs:element name="streamOnSettings" type="SettingsInfo" />
            <xs:element name="streamOffSettings" type="SettingsInfo" />
            <xs:element name="groupHoldOnSettings" type="SettingsInfo" />
            <xs:element name="groupHoldOffSettings" type="SettingsInfo" />
            <xs:element name="masterSettings" type="SettingsInfo" minOccurs="0"/>
            <xs:element name="slaveSettings" type="SettingsInfo" minOccurs="0"/>
            <xs:element name="initSettings" type="InitSettings" maxOccurs="unbounded" />
            <xs:element name="testPatternInfo" type="TestPatternInformation" />
            <xs:element name="colorLevelInfo" type="ColorLevelInformation" />
            <xs:element name="opticalBlackRegionInfo" type="OpticalBlackRegionInfo" />
            <xs:element name="pixelArrayInfo" type="PixelArrayInfo" />
            <xs:element name="delayInfo" type="DelayInfo"  minOccurs="1" maxOccurs="2"/>
            <xs:element name="sensorProperty" type="SensorProperty" />
            <!-- Either noiseCoefficient or noiseCoefficientBayer, noiseCoefficientBayer will be used if both are defined -->
            <xs:element name="noiseCoefficent" type="NoiseCoefficent" minOccurs="0"/>
            <xs:element name="noiseCoefficientBayer" type="NoiseCoefficientBayer" minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>
    <xs:element name="sensorDriverData" type="SensorDriverData"/>
</xs:schema>
