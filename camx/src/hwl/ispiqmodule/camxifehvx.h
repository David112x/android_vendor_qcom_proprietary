////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2017-2018 Qualcomm Technologies, Inc.
// All Rights Reserved.
// Confidential and Proprietary - Qualcomm Technologies, Inc.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @file  camxifehvx.h
/// @brief ife HVX lass declarations
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef CAMXIFEHVX_H
#define CAMXIFEHVX_H

// Camx includes
#include "camxformats.h"
#include "camxispiqmodule.h"
#include "chiisphvxdefs.h"
#include "camxifedspinterface.h"
#include "titan170_ife.h"

CAMX_NAMESPACE_BEGIN

/// @brief DSPState
enum DSPState
{
    DSP_STATE_INVALID = 0,                 ///< Invalid state
    DSP_STATE_INITIALIZE,                  ///< Initial State
    DSP_STATE_OPENED,                      ///< Open State
    DSP_STATE_CONFIGURED,                  ///< Configuration Success
    DSP_STATE_STREAMING,                   ///< Streaming state
    DSP_STATE_MAX,                         ///< Max State
};

/// @brief CAMXHVXParameters
struct CAMXHVXParameters
{
    HVXGetSetInfo                 HVXInfo;           ///< hvx info
    HVXResolutionInfo             resInfo;           ///< Resolution info
    UINT32                        requestId;         ///< RequestId
    enum HVXStubVFEType           stubIfeType;       ///< vfe stub type
    CHIISPHVXALGORITHMCALLBACKS*  pHVXAlgoCallbacks;  ///< function table to store OEM lib *function poINTers
    VOID*                         pOEMData;          ///< OEM private data
    HVXStubSetCallbackFunc        setCallbackFunc;   ///< Callback functons
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief Class for IFE HVX Module
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class IFEHVX final : public ISPIQModule
{
public:
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Create
    ///
    /// @brief  Create IFEWB12 Object
    ///
    /// @param  pCreateData Pointer to data for Demux Creation
    ///
    /// @return CamxResultSuccess if successful
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static CamxResult Create(
        IFEModuleCreateData* pCreateData);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// GetHVXInputResolution
    ///
    /// @brief  Get HVX Input Resiolution
    ///
    /// @param  pInputData Pointer to the Inputdata
    ///
    /// @return CamxResultSuccess if successful.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    CamxResult GetHVXInputResolution(
        ISPInputData * pInputData);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// InitConfiguration
    ///
    /// @brief  Initialize HVX Configuration
    ///
    /// @param  pInputData Pointer to the Inputdata
    ///
    /// @return CamxResultSuccess if successful.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    CamxResult InitConfiguration(
        ISPInputData * pInputData);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Execute
    ///
    /// @brief  Execute process capture request to configure module
    ///
    /// @param  pInputData Pointer to the Inputdata
    ///
    /// @return CamxResultSuccess if successful.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    virtual CamxResult Execute(
        ISPInputData* pInputData);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// PrepareStripingParameters
    ///
    /// @brief  Prepare striping parameters for striping lib
    ///
    /// @param  pInputData Pointer to the Inputdata
    ///
    /// @return CamxResultSuccess if successful.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    virtual CamxResult PrepareStripingParameters(
        ISPInputData* pInputData);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// PrepareStreamOn
    ///
    /// @brief  virtual method to that will be called before streamOn command is sent to HW. HW nodes may use
    ///         this hook to do any preparation, or per-configure_stream one-time configuration.
    ///         This is generally called in FinalizePipeline, i.e within a lifetime of pipeline, this is called only once.
    ///         Actual StreamOn may happen much later based on Activate Pipeline. Nodes can use this to do any one time
    ///         setup that is needed before stream.
    ///
    /// @return CamxResultSuccess if successful.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    CamxResult PrepareStreamOn();

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// OnStreamOff
    ///
    /// @brief  virtual method to that will be called before streamOff command is sent to HW. HW nodes may use
    ///         this hook to do any preparation. This is generally called on every Deactivate Pipeline.
    ///         Nodes may use this to release things that are not required at the end of streaming. For exa, any resources
    ///         that are not needed after stream-on can be released here. Make sure to do light weight operations here as
    ///         releasing here may result in re-allocating resources in OnStreamOn.
    ///
    /// @param  modeBitmask Stream off mode bitmask
    ///
    /// @return CamxResultSuccess if successful.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    CamxResult OnStreamOff(
        CHIDEACTIVATEPIPELINEMODE modeBitmask);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// GetHVXTapPoint
    ///
    /// @brief  GetHVXTapPoint
    ///
    /// @return HVXTapPoint
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    CAMX_INLINE HVXTapPoint GetHVXTapPoint()
    {
        return m_tapPoint;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// GetDualIFEData
    ///
    /// @brief  Provides information on how dual IFE mode affects the IQ module
    ///
    /// @param  pDualIFEData Pointer to dual IFE data the module will fill in
    ///
    /// @return None
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    virtual VOID GetDualIFEData(
        IQModuleDualIFEData* pDualIFEData)
    {
        CAMX_ASSERT(NULL != pDualIFEData);

        pDualIFEData->dualIFESensitive = TRUE;
    }

protected:
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// ~IFEHVX
    ///
    /// @brief  Destructor
    ///
    /// @return None
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    virtual ~IFEHVX();

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// IFEHVX
    ///
    /// @brief  Constructor
    ///
    /// @return None
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    IFEHVX();

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// IFEHVX
    ///
    /// @brief  Constructor
    ///
    /// @param  pHvxInitializeData Pointer to the Initialization from CHI
    ///
    /// @return None
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    explicit IFEHVX(
       IFEHVXInfo* pHvxInitializeData);

private:
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// CheckDependenceChange
    ///
    /// @brief  Check if the Dependence Data has changed
    ///
    /// @param  pInputData Pointer to the Input Data
    ///
    /// @return TRUE if dependence is meet
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    BOOL CheckDependenceChange(
        const ISPInputData* pInputData);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// SetConfiguration
    ///
    /// @brief  Perform the Calculation
    ///
    /// @return CamxResultSuccess if successful
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    CamxResult SetConfiguration();

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// IFEConvertSensorFormat
    ///
    /// @brief  Convert Sensor format to HVX sensor format
    ///
    /// @param  pPixelFormat Pointer to the Sensor format
    /// @param  pSensorType  Pointer to the HVX sensor format
    ///
    /// @return CamxResultSuccess if successful
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    CamxResult IFEConvertSensorFormat(
        const PixelFormat*          pPixelFormat,
        HVXSensorFilterArrangement* pSensorType);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// RunCalculation
    ///
    /// @brief  Perform the Calculation
    ///
    /// @return CamxResultSuccess if successful
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    CamxResult RunCalculation();

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// UnInitialize
    ///
    /// @brief  Uniintialize HVX
    ///
    /// @return CamxResultSuccess if successful.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    CamxResult UnInitialize();


    IFEHVX(const IFEHVX&) = delete;                  ///< Disallow the copy constructor
    IFEHVX& operator=(const IFEHVX&) = delete;       ///< Disallow assignment operator

    HVXTapPoint       m_tapPoint;                    ///< tap Point for the HVX
    CAMXHVXParameters m_HVXParams;                   ///< HVX Params
    INT               m_hDSPHandle;                  ///< DSP handle
    HVXInputData      m_dependenceData;              ///< Input to the HVX
    HVXConfig         m_config;                      ///< configuration for HVX
    HVXState*         m_pState;                      ///< HVX state
    DSPState          m_dspState;                    ///< Current Dsp state
};

CAMX_NAMESPACE_END

#endif // CAMXIFEWB12_H
