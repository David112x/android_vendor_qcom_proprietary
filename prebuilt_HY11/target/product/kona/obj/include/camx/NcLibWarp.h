// NOWHINE ENTIRE FILE
//-------------------------------------------------------------------------
// Copyright (c) 2017-2019 Qualcomm Technologies, Inc.
// All Rights Reserved.
// Confidential and Proprietary - Qualcomm Technologies, Inc.
//------------------------------------------------------------------------

#ifndef __NC_LIB_WARP_API__
#define __NC_LIB_WARP_API__

/*------------------------------------------------------------------------
 * @file  NcLibWarp.h
 * @brief NcLib Warp API functions
 *
 *  Warping Order (this is true for any WarpDirection)
 *
 *                 ________    Intermediate    ___________
 *      Input     |        |   Image Domain   |           |     Output
 *      Image --->|  Grid  |----------------->|  Matrices |---> Image
 *      Domain    |________|                  |___________|     Domain
 *
 *------------------------------------------------------------------------*/

/*------------------------------------------------------------------------
*       Include Files
* ----------------------------------------------------------------------- */
#include <stdint.h>

#include "NcLibContext.h"               /* FD */

#include "NcLibWarpCommonDef.h"

#ifdef __cplusplus
extern "C" {
#endif

/*------------------------------------------------------------------------
*       Definitions
* ----------------------------------------------------------------------- */

/* Extrapolation points */
#define NC_LIB_WARP_EXTRAP_TOP_LEFT_IDX       (0)                                       /**< Top left extrapolation point index */
#define NC_LIB_WARP_EXTRAP_TOP_RIGHT_IDX      (NC_LIB_WARP_EXTRAP_TOP_LEFT_IDX + 1)     /**< Top right extrapolation point index */
#define NC_LIB_WARP_EXTRAP_BOTTOM_LEFT_IDX    (NC_LIB_WARP_EXTRAP_TOP_RIGHT_IDX + 1)    /**< Bottom left extrapolation point index */
#define NC_LIB_WARP_EXTRAP_BOTTOM_RIGHT_IDX   (NC_LIB_WARP_EXTRAP_BOTTOM_LEFT_IDX + 1)  /**< Bottom right extrapolation point index */

/** NcLibCheckIcaTransformValidity() intermediate buffer size - required for internal calculations */
#define NC_LIB_WARP_CHECK_ICA20_INTERMEDIATE_BUFFER_SIZE     (sizeof(NcLibWarpGridCoord) * 3417)
#define NC_LIB_WARP_CHECK_ICA30_INTERMEDIATE_BUFFER_SIZE     (sizeof(NcLibWarpGridCoord) * 12969)

/*------------------------------------------------------------------------
*       Type Declarations
* ----------------------------------------------------------------------- */
#pragma pack(push)
#pragma pack(4)

/** Domain of alignment matrix */
typedef enum NcLibWarpImageDomain_t
{
    INPUT_IMAGE_DOMAIN = 0,     /**< Input image with no grid or matrices applied */
    INTERMEDIATE_IMAGE_DOMAIN,  /**< Intermediate image after grid applied but before matrices applied */
    OUTPUT_IMAGE_DOMAIN         /**< Output image after grid and matrices applied */
}NcLibWarpImageDomain;

/**< Two dimensional coordinate or window */
struct NcLibFloat2
{
    float                           x;                      /**< can be coordinate or window width   */
    float                           y;                      /**< can be coordinate or window height  */
};

/**< Fractional ROI or FOV rectangle normalized on [0..1] */
struct NcLibROI
{
    NcLibFloat2                    offset;                 /**< on domain 1x1 */
    NcLibFloat2                    size;                   /**< on domain 1x1 */
};


/** Input struct for the NcLibWarpBuildAssistGrid() function */
typedef struct NcLibWarpBuildAssistGridIn_t
{
    const NcLibWarp*    in;             /**< Input Warp struct in virtual domain, as
                                         *   converted by NcLibWarpConvertToVirtualDomain().
                                         */
    uint32_t            numColumns;     /**< Number of columns in assists grid. Must be greater than 1. */
    uint32_t            numRows;        /**< Number of rows in assists grid. Must be greater than 1. */

}NcLibWarpBuildAssistGridIn;

/** Output struct of NcLibWarpBuildAssistGrid() function, should be buffer by the user for next frame */
typedef struct NcLibWarpBuildAssistGridOut_t
{
    NcLibWarpGrid*      assistGrid;     /**< Assist grid generated by NcLibWarpBuildAssistGrid() for current frame */
    NcLibWarp*          inputWarp;      /**< If NULL, assumed to be buffered by the user. And pointer assigned to
                                         *   inputWarp externally before calling to NcLibWarpGeometries(). Otherwise
                                         *   will contain the warp grid from previous input
                                         */
}NcLibWarpBuildAssistGridOut;

/** NcLibWarpGeometries() input struct */
typedef struct NcLibWarpGeomIn_t
{
    //TODO (etsairi): need to consider all the bellow image dim + zoom dim parameters?
    NcLibImageSize                      inputSize;              /**< Input image dimensions (as supplied to FW) */
    NcLibImageSize                      stabilizationMargins;   /**< Stabilization total margin (as supplied to FW) */
    NcLibWindowRegion                   zoomWindow;             /**< Output zoom window. (as supplied to FW) */
    NcLibWindowRegion                   ifeZoomWindow;          /**< IFE output zoom window. (as supplied to FW) */
    float                               ica1UpScaleRatio;       /**< Upscale which is done in ICA, but not
                                                                 *   implemented in the matrices
                                                                 */

    const NcLibWarpBuildAssistGridOut*  inputGrids;             /**< As calculated by NcLibWarpBuildAssistGrid()
                                                                 *   in current frame
                                                                 */
    const NcLibWarpBuildAssistGridOut*  inputGridsPrevFrame;    /**< As calculated by NcLibWarpBuildAssistGrid() in
                                                                 *   previous frame and was buffered.
                                                                 *   Used in case (true == isFdConfigFromPrevFrame) &&
                                                                 *                (DISTORTED != aligmentDomain)
                                                                 *   - otherwise could be NULL.
                                                                 */

    /* FD parameters */
    const FD_CONFIG_CONTEXT*            fdConfig;               /**< Holds the latest available face detection
                                                                *   parameters (from current or previous frame).
                                                                *   Assumed to be in coordinates of inputSize.
                                                                */
    bool                                isFdConfigFromPrevFrame;/**< If true, then FD parameters are from previous
                                                                *   frame, otherwise from current frame
                                                                */

    NcLibWarpImageDomain                alignmentDomain;        /**< Domain of alignment matrix */
    const NcLibWarp*                    alignment;              /**< If (true == isFdConfigFromPrevFrame), then this
                                                                 *   matrix will be used to estimate the movement of
                                                                 *   face centers from previous frame. Warp was
                                                                 *   adjusted by NcLibWarpConvertToVirtualDomain().
                                                                 */

    NcLibWarpImageDomain                lnrDomain;              /**< Domain of LNR */

    /* TF */
    PARAM_UINT                          tf_lnr_opt_center_x;    /**< x-coordinate of TF LNR center as assigned
                                                                *   to Chromatix input struct.
                                                                *   A logical values between [0,1].
                                                                *   format: 15uQ14
                                                                */
    PARAM_UINT                          tf_lnr_opt_center_y;    /**< y-coordinate of TF LNR center as assigned
                                                                *   to Chromatix input struct.
                                                                *   A logical values between [0,1]
                                                                */

    /* ANR */
    PARAM_UINT                          anr_lnr_opt_center_x;   /**< Optical center of ANR LNR.as assigned
                                                                 *   to Chromatix input struct.
                                                                 *   A logical values between [0,1]
                                                                 *   format: 15uQ14
                                                                 */
    PARAM_UINT                          anr_lnr_opt_center_y;   /**< Optical center of ANR LNR. as assigned
                                                                 *   to Chromatix input struct.
                                                                 *   A logical values between [0,1]
                                                                 *   format: 15uQ14
                                                                 */

    /* ASF */
    PARAM_UINT                          asf_opt_center_x;       /**< Optical center of ASF. As assigned
                                                                 *   to Chromatix input struct.
                                                                 *   A logical values between [0,1]
                                                                 *   format: 15uQ14
                                                                 */

    PARAM_UINT                          asf_opt_center_y;       /**< Optical center of ASF. As assigned
                                                                 *   to Chromatix input struct.
                                                                 *   A logical values between [0,1]
                                                                 *   format: 15uQ14
                                                                 */

    /* LENR */
    PARAM_UINT                          lenr_opt_center_x;     /**< Optical center of LENR. As assigned
                                                                *   to Chromatix input struct.
                                                                *   A logical values between [0,1]
                                                                *   format: 15uQ14
                                                                */

    PARAM_UINT                          lenr_opt_center_y;     /**< Optical center of LENR. As assigned
                                                                *   to Chromatix input struct.
                                                                *   A logical values between [0,1]
                                                                *   format: 15uQ14
                                                                */

    /* HNR */
    PARAM_UINT                          hnr_opt_center_x;       /**< Optical center of HNR. As assigned
                                                                *   to Chromatix input struct.
                                                                *   A logical values between [0,1]
                                                                *   format: 15uQ14
                                                                */

    PARAM_UINT                          hnr_opt_center_y;       /**< Optical center of HNR. As assigned
                                                                *   to Chromatix input struct.
                                                                *   A logical values between [0,1]
                                                                *   format: 15uQ14
                                                                */
}NcLibWarpGeomIn;

/** NcLibWarpGeometries() output struct */
typedef struct NcLibWarpGeomOut_t
{
    /* FD parameters */
    FD_CONFIG_CONTEXT*              fdConfig;                   /**< Corrected FD parameters in coordinates
                                                                 *   of after Warp (reduced image size).
                                                                 */

    /* TF */
    PARAM_UINT                      tf_lnr_opt_center_x;        /**< x-coordinate of TF LNR center as assigned
                                                                 *   to Chromatix input struct.
                                                                 *   A logical values between [0,1]
                                                                 *   format: 15uQ14
                                                                 */
    PARAM_UINT                      tf_lnr_opt_center_y;        /**< y-coordinate of TF LNR center as assigned
                                                                 *   to Chromatix input struct.
                                                                 *   A logical values between [0,1]
                                                                 *   format: 15uQ14
                                                                 */

    /* ANR */
    PARAM_UINT                      anr_lnr_opt_center_x;       /**< Optical center of ANR LNR center as assigned
                                                                  *   to Chromatix input struct.
                                                                  *   A logical values between [0,1]
                                                                  *   format: 15uQ14
                                                                  */
    PARAM_UINT                      anr_lnr_opt_center_y;       /**< Optical center of ANR LNR center as assigned
                                                                  *   to Chromatix input struct.
                                                                  *   A logical values between [0,1]
                                                                  *   format: 15uQ14
                                                                  */

    /* ASF  */
    PARAM_UINT                      asf_opt_center_x;           /**< Optical center of ASF. As assigned
                                                                 *   to Chromatix input struct.
                                                                 *   A logical values between [0,1]
                                                                 *   format: 15uQ14
                                                                 */

    PARAM_UINT                      asf_opt_center_y;           /**< Optical center of ASF. As assigned
                                                                 *   to Chromatix input struct.
                                                                 *   A logical values between [0,1]
                                                                 *   format: 15uQ14
                                                                 */
    /* LENR */
    PARAM_UINT                          lenr_opt_center_x;     /**< Optical center of LENR. As assigned
                                                               *   to Chromatix input struct.
                                                               *   A logical values between [0,1]
                                                               *   format: 15uQ14
                                                               */

    PARAM_UINT                          lenr_opt_center_y;     /**< Optical center of LENR. As assigned
                                                               *   to Chromatix input struct.
                                                               *   A logical values between [0,1]
                                                               *   format: 15uQ14
                                                               */

    /* HNR */
    PARAM_UINT                          hnr_opt_center_x;       /**< Optical center of HNR. As assigned
                                                                *   to Chromatix input struct.
                                                                *   A logical values between [0,1]
                                                                *   format: 15uQ14
                                                                */

    PARAM_UINT                          hnr_opt_center_y;       /**< Optical center of HNR. As assigned
                                                                *   to Chromatix input struct.
                                                                *   A logical values between [0,1]
                                                                *   format: 15uQ14
                                                                */
}NcLibWarpGeomOut;


/** NcLibCalcMctfTransform() input struct */
typedef struct NcLibCalcMctfIn_t
{
    const NcLibImageSize*           inputSize;              /**< Input image dimensions */
    const NcLibImageSize*           stabilizationMargins;   /**< Stabilization total margin (as supplied to FW) */

    NcLibWarpImageDomain            alignmentDomain;        /**< Domain of alignment matrix */

    const NcLibWarp*                alignment;              /**< Alignment transform (grid or matrix).
                                                             *   Warp was adjusted by NcLibWarpConvertToVirtualDomain().
                                                             */

    const NcLibWarp*                inputWarp;               /**< Input Warp struct in virtual domain, as converted
                                                              *   by NcLibWarpConvertToVirtualDomain().
                                                              */

    const NcLibWarpBuildAssistGridOut*  inputGrids;          /**< Current frame assist grid as calculated
                                                              *    by NcLibWarpBuildAssistGrid()
                                                              */

    const NcLibWarpBuildAssistGridOut*  inputGridsPrevFrame;    /**< Previous frame assist grid as calculated
                                                                 *    by NcLibWarpBuildAssistGrid() and was buffered
                                                                 *    in previous frame
                                                                 */
}NcLibCalcMctfIn;

/** NcLibCheckIcaTransformValidity() input struct */
typedef struct NcLibCheckIcaTransformValidityIn_t
{
    const NcLibWarp*          warp;                   /**< Warping transform to be checked for validity */
    NcLibImageSize            outputSize;             /**< Output image dimensions */
    uint32_t                  halfOutputW;            /**< Half output image width - special parameter present in ICA.
                                                       *   Usually = outputSize.widthPixels/2
                                                       */
    NcLibImageSize            inputSize;              /**< Input image dimensions */

    NcLibWindowRegion         outputRoi;              /**< ROI in output domain - output image is mapped to this ROI in
                                                       *   output virtual domain (the ROI is given in relative form - window size vs full size) */
    NcLibWindowRegion         inputRoi;               /**< ROI in input domain - input image is mapped to this ROI
                                                       *   in input virtual domain
                                                       */
    bool                      enableRoi;              /**< Whether ROI (zoom windows) in input and output domains are enabled */
} NcLibCheckIcaTransformValidityIn;

/** Grid triangulation type */
typedef enum NcLibUniformGridTriangulation_t
{
    TRIANGLE_STRIP_NE_DIRECTION = 0,        /**< |/|/|/|...   */
    TRIANGLE_STRIP_NW_DIRECTION = 1,        /**< |\|\|\|...   */
    TRIANGLE_STRIP_TOGGLING_DIRECTION = 2   /**< |/|\|/|...
                                                 |\|/|... */
} NcLibUniformGridTriangulation;

/* Extrapolation type */
typedef enum NcLibReverseGridExtrapolationType_t
{
    REVERSE_GRID_EXTRAPOLATION_NEAREST,                  /**< Duplicate the coordinate of nearest neighbor */
    REVERSE_GRID_EXTRAPOLATION_MV_NEAREST,               /**< Duplicate the motion vector of nearest neighbor */
    REVERSE_GRID_EXTRAPOLATION_APPROX_LINEAR             /**< Approximate linear extrapolation (this is the recommended value)  */
} NcLibReverseGridExtrapolationType;

/** NcLibWarpReverseGridDirection() input struct */
typedef struct NcLibWarpReverseGridDirectionIn_t
{
    uint32_t                      numRows;                           /**< Number of rows in (forward) arrays srcGridRowCoords and dstCoords */
    uint32_t                      numColumns;                        /**< Number of columns in (forward) arrays srcGridColumnCoords and dstCoords */
    float*                        srcGridRowCoords;                  /**< Source rectangular grid - location of rows */
    float*                        srcGridColumnCoords;               /**< Source rectangular grid - location of columns */
    NcLibWarpGridCoord*           dstCoords;                         /**< 2-dimensional array of destination coordinates */
    NcLibUniformGridTriangulation inputTriangulationType;            /**< Triangulation type to be used at source grid */
    NcLibReverseGridExtrapolationType extrapolationType;             /**< Extrapolation type used for out-of-grid samples.
                                                                      *   Recommended value is REVERSE_GRID_EXTRAPOLATION_APPROX_LINEAR. */
    uint32_t                      reversedGridNumRows;               /**< Number of rows in reversed grid */
    uint32_t                      reversedGridNumColumns;            /**< Number of columns in reversed grid */
    NcLibWarpGridCoord            reversedGridSourceTopLeft;         /**< Reversed grid: first x and y coordinate of source grid */
    NcLibWarpGridCoord            reversedGridSourceBottomRight;     /**< Reversed grid: last x and y coordinate of source grid */
    bool                          useExtraCalcsDuringExtrpolation;   /**< Relevant only when extrapolationType is equal to
                                                                      *   REVERSE_GRID_EXTRAPOLATION_NEAREST or REVERSE_GRID_EXTRAPOLATION_MV_NEAREST.
                                                                      *  Indicates that extra calculations will be done in order
                                                                      *  to handle corner cases during extrapolation (if required).
                                                                      *  By default should be false to avoid run time penalty.
                                                                      */
} NcLibWarpReverseGridDirectionIn;

/** Struct that contains the statistics on the operation of NcLibWarpReverseGridDirection() */
typedef struct NcLibWarpReverseGridStatistics_t
{
    float extrapolationPercentage;      /**< Percentage of the Grid points that were extrapolated */
}NcLibWarpReverseGridStatistics;
#pragma pack(pop)

/** Alignment mode */
enum NcLibAlignmentMode
{
    NCLIB_ALIGN_IMAGE_BASED_ONLY,
    NCLIB_ALIGN_GYRO_BASED_ONLY,
    NCLIB_ALIGN_AUTO
};

/** Alignment type */
enum NcLibAlignmentType
{
    NCLIB_ALIGN_IMAGE_BASED,
    NCLIB_ALIGN_GYRO_BASED,
    NCLIB_NO_ALIGNMENT
};

/** NcLibAlignmentFusion() input struct */
struct NcLibAlignmentFusionIn
{
    NcLibWarp*         imageAlign;                        /**< Alignment transform as received from CVP/LRME RANSAC. */
    bool               imageAlignForcedToIdentity;        /**< Is CVP/LRME RANSAC forced to identity, as indicated by RANSAC. */
    NcLibWarp*         gyroAlign;                         /**< Alignment transform received from EIS library. */

    NcLibAlignmentMode mode;                              /**< Alignment mode set in Chromatix. */
    int32_t           imageConfHighThreshold;             /**< RANSAC confidence high threshold set in Chromatix. Will switch from
                                                           *   gyro to image based only if RANSAC confidence is above this threshold.
                                                           *   Range: -1:257.
                                                           */
    int32_t           imageConfLowThreshold;              /**< Low threshold of RANSAC confidence set in Chromatix. Will switch from
                                                           *   image based to gyro only if RANSAC confidence is below this threshold.
                                                           *   Range: -1:257.
                                                           */
    uint32_t           minAge;                            /**< Minimum alignment type frames set in Chromatix. Will switch between gyro
                                                           *   and image based only if did not change type for this number of frames.
                                                           */
    float              absoluteMotion;                    /**< Optional motion indication in pixels, e.g. AMD result. TBD: resolution / dimension. */
    float              absoluteMotionThreshold;           /**< Threshold in pixels set in Chromatix. Absolute motion below this value
                                                           *   will be considered as no motion. TBD: resolution / dimension. */
    uint32_t           absoluteMotionConfidence;          /**< Confidence of motion indication. Range: 0:256. Set to 0 if no indication is present. */
    uint32_t           absoluteMotionConfidenceThreshold; /**< Threshold above which absolute motion is valid. */

    NcLibAlignmentType prevAlignment;                     /**< alignmentType returned from NcLibAlignmentFusion for previous frame. */
    uint32_t           prevAge;                           /**< age returned from NcLibAlignmentFusion for previous frame. */
};

/** NcLibAlignmentFusion() output struct */
struct NcLibAlignmentFusionOut
{
    NcLibWarp*            alignmentTransform;  /**< Will point to either imageAlign or gyroAlign. May be NULL if alignmentType
                                                *   is NCLIB_NO_ALIGNMENT, in which case unity matrix should be used.
                                                */
    NcLibAlignmentType    alignmentType;       /**< The selected alignment. Need to be saved for the next frame. */
    uint32_t              age;                 /**< The selected alignment age in frames. Need to be saved for the next frame. */
};


/** Input struct for NcLibTranslateFdDomains */
struct NcLibRectangle
{
    int32_t left;
    int32_t top;
    int32_t width;
    int32_t height;
};

/*------------------------------------------------------------------------
*       API Functions
* ----------------------------------------------------------------------- */

/**
*  @brief   Converts Warp struct from general domain into virtual domain
*
*  @param [in]      in      Input struct
*  @param [in,out]  out     Output Warp struct, buffer is allocated by the user.
*
*  @return NC_LIB_SUCCESS in case of success, otherwise failed.
*/
int32_t NcLibWarpConvertToVirtualDomain(
    const NcLibWarp* in,
    NcLibWarp*       out);

/**
*  @brief   Generates assist grid from matrices
*
*  @param [in]      in      Input struct
*  @param [in,out]  out     Output Warp struct, buffer is allocated by the user.
*
*  @return NC_LIB_SUCCESS in case of success, otherwise failed.
*/
int32_t NcLibWarpBuildAssistGrid(
    const NcLibWarpBuildAssistGridIn*    in,
    NcLibWarpBuildAssistGridOut*         out);

/**
*  @brief   NcLibGetMaxNumOfPasses used to determined maximal number of passes in IPE
*           All input sizes are defined for digital zoom of X1 (no digital zoom)
*           Number of passes does not depend on digital zoom. ( DC4/DC16/DC64 size won't be decrease )
*
*  @param [in]      ipeInputSize            Input image dimensions for IPE (as supplied to FW)
*  @param [in]      stabilizationMargins    Stabilization total margin (as supplied to FW)
*  @param [in]      icaUpScaleRatio_AtDZx1  upscale done in ICA for digital zoom X1, example upscale for
*                                                        MFSR in DZ=1 or upscale for virtual margins that is done in ICA
*                                                        (currently it is done in QSeed)
*  @param [in]      maxNumOfPassesByFlow    limit max number of passes according to flow decision,
*                                           for example video uses max of 3 passes regardless of image size
*
*  @param [out]     maxNumOfPasses          Output Warp struct, buffer is allocated by the user.
*
*  @return NC_LIB_SUCCESS in case of success, otherwise failed.
*/
int32_t NcLibGetMaxNumOfPasses(
    const NcLibImageSize*        ipeInputSize,
    const NcLibImageSize*        stabilizationMargins,
    float                        icaUpScaleRatio_AtDZx1,
    uint32_t                     maxNumOfPassesByFlow,
    uint32_t*                    maxNumOfPasses);


/**
*  @brief   Corrects LNR and FD parameters according to LDC / Stabilization that was performed.
*
*  @param [in]      in      Input struct
*  @param [in,out]  out     Output Warp struct, buffer is allocated by the user.
*
*  @return NC_LIB_SUCCESS in case of success, otherwise failed.
*/
int32_t NcLibWarpGeometries(
    const NcLibWarpGeomIn*   in,
    NcLibWarpGeomOut*        out);

/**
*  @brief   Adjust alignment matrix with Stabilization to get MCTF alignment matrix, generates a transform
*           from previous stabilized image to current stabilized image.
*
*  @param [in]      in          Input struct
*  @param [in]      outDomain   Domain the Output Warp domain is calculated for.
*  @param [in,out]  out         Output Warp struct, buffer is allocated by the user.
*
*  @return NC_LIB_SUCCESS in case of success, otherwise failed.
*/
int32_t NcLibCalcMctfTransform(
    const NcLibCalcMctfIn*          in,
    const NcLibWarpImageDomain      outDomain,
    NcLibWarp*                      out);

/**
*  @brief   Align input image transform to aggregated anchor MCTF image.
*
*  @param [in]      transform     Input Warp struct in virtual domain, as converted
*                                       by NcLibWarpConvertToVirtualDomain().
*  @param [in]      alignment     Alignment transform in virtual domain, as converted
*                                       by NcLibWarpConvertToVirtualDomain().
*  @param [in,out]  out           Output Warp struct, buffer is allocated by the user.
*
*  @return NC_LIB_SUCCESS in case of success, otherwise failed.
*/
int32_t NcLibCalcMfnrTransform(
    const NcLibWarp*                transform,
    const NcLibWarp*                alignment,
    NcLibWarp*                      out);

/**
*  @brief   Check NcLib warp struct validity, when applied in ICA.
*
*  @param [in]      in              Input struct
*  @param [in]      fastMode        If true and high resolution grid, will perform a faster but less accurate calculation
*  @param [in,out]  intermediate    Buffer used for internal calculations,
*                                   size of buffer is defined by NC_LIB_WARP_CHECK_ICA_INTERMEDIATE_BUFFER_SIZE
*  @param [out]     valid           Whether the input transformation is valid
*
*  @return NC_LIB_SUCCESS in case of success, otherwise failed.
*/
int32_t NcLibCheckIcaTransformValidity(
    const NcLibCheckIcaTransformValidityIn* in,
    bool                                    fastMode,
    void*                                   intermediate,
    int32_t*                                valid);

/**
*  @brief   Given uniform input grid generates uniform inverse grid (AKA out2in conversion).
*           The function allocates a temporary buffer of approximately 16 * (grid width + height) bytes.
*
*  @param [in]  in              Input struct
*  @param [out] out             Output (reversed-direction) grid points. It is assumed to be pre-allocated (sizeof(NcLibWarpGridCoord) * grid size).
*  @param [out] outStats        (Optional) if not-NULL, then contains the statistics of NcLibWarpReverseGridDirection()
*                               execution.
*
*  @return NC_LIB_SUCCESS in case of success, otherwise failed.
*/
int32_t NcLibWarpReverseGridDirection(
    const NcLibWarpReverseGridDirectionIn*  in,
    NcLibWarpGridCoord*                     out,
    NcLibWarpReverseGridStatistics*         outStats);

/**
*  @brief   Adjust transform grid (e.g. LDC) to a new cropped and zoomed window. The input grid is provided for full FOV mapped
*           to whole virtual domain and the output grid corresponds to new window mapped to whole virtual domain.
*
*  @param [in]  in              Original grid. Coordinates must be provided in virtual domain (i.e. transformDefinedOn should be
*                               VIRTUAL_DOMAIN_WIDTH x VIRTUAL_DOMAIN_HEIGHT).
*  @param [in]  winAtOut        Matching window in output domain.
*  @param [in]  winAtIn         The crop window in input domain.
*  @param [out] out             Output grid matching the IFE zoom window, in virtual domain. Assumed to be pre-allocated.
*
*  @return NC_LIB_SUCCESS in case of success, otherwise failed.
*/
int32_t NcLibResampleGrid(
    const NcLibIcaGrid*      in,
    const NcLibWindowRegion* winAtOut,
    const NcLibWindowRegion* winAtIn,
    NcLibIcaGrid*            out);

/**
*  @brief   Calculate minimal distorted window that holds the required data for production of given undistorted window.
*           The returned window is scaled to winAtOut size (winAtIn full size = winAtOut full size).
*           The calculated window does not respect any additional constraints like even number of pixels, centering, aspect
*           ratio, etc.; so further enlargement may be required.
*
*  @param [in]  winAtOut        Required window in undistorted domain.
*  @param [in]  grid            Out-to-in grid. Coordinates must be provided in virtual domain (i.e. transformDefinedOn
*                               should be VIRTUAL_DOMAIN_WIDTH x VIRTUAL_DOMAIN_HEIGHT).
*  @param [out] winAtIn         Matching window in distorted domain scaled to winAtOut size.
*                               Actual window should fully contain this window.
*
*  @return NC_LIB_SUCCESS in case of success, otherwise failed.
*/
int32_t NcLibCalcMinInputWindow(
    const NcLibWindowRegion* winAtOut,
    const NcLibIcaGrid*      grid,
    NcLibWindowRegion*       winAtIn);


/**
*  @brief   Calculate maximum undistorted window that can be produced from distorted window.
*           The out ROI center is assumed to be in the center of virtual domain. The aspect ratio and full output size are
*           derived from origWinAtOut. Other constraints are ignored, like even number of pixels, etc. Thus further reduction
*           may be required.
*
*  @param [in]  winAtIn         Available window in distorted domain.
*  @param [in]  origWinAtOut    Original window in undistorted domain, from which winAtIn was derived. Output aspect ratio and
*                               full size are derived from this window.
*  @param [in]  grid            In-to-out grid. Coordinates must be provided in virtual domain (i.e. transformDefinedOn
*                               should be VIRTUAL_DOMAIN_WIDTH x VIRTUAL_DOMAIN_HEIGHT).
*  @param [out] winAtOut        Matching window in undistorted domain. Actual window should be fully contained in this window.
*
*  @return NC_LIB_SUCCESS in case of success, otherwise failed.
*/
int32_t NcLibCalcMaxOutputWindow(
    const NcLibWindowRegion* winAtIn,
    const NcLibWindowRegion* origWinAtOut,
    const NcLibIcaGrid*      grid,
    NcLibWindowRegion*       winAtOut);

/**
*  @brief   GMO is Global Motion transform provided to Video encoder.
            GMO is based on ICA2 transform - the only difference is PPS crop&upscale (usually due to DZ).
            ICA2 transform already defines the motion between current and previous full images.
            ICA2 is not aware of PPS scaling and offset that is done in PPS on current and previous images.

            It is assumed that matrices (alignmentMatrix amd gmoMatrix) are in this format:
            x(n-1) = Mx(n)

*
*  @param [in]  alignmentMatrix              Original ICA2 alignment matrix.
*  @param [in]  isAlignmentMatrixCentralized If true, the alignmentMatrix is centralized (so that
                                             coordinate of the center of top-left pixel is
                                             [-(width-1)/2, -(height-1)/2]).
                                             If false, the alignmentMatrix is relative to top-left
                                             (assuming [0,0] is in the center of top-left pixel).
*  @param [in]  currZoomWindow               Current Zoom window (the window coordinates are relative to top-left).
                                             Defines crop done by PPS and it is assumed that the cropped
                                             window is upscaled to full window size.
*  @param [in]  prevZoomWindow               Previous Zoom window (the window coordinates are relative to top-left)
*  @param [out] gmoMatrix                    The GMO matrix. The matrix is centralized.
*
*  @return NC_LIB_SUCCESS in case of success, otherwise failed.
*/
int32_t NcLibGenerateGMO(
    const NcLibPerspTransformSingle* alignmentMatrix,
    bool                             isAlignmentMatrixCentralized,
    const NcLibWindowRegion*         currZoomWindow,
    const NcLibWindowRegion*         prevZoomWindow,
    NcLibPerspTransformSingle*       gmoMatrix);


/**
*  @brief HFR is done as batch processing. Alignment matrix is calculated up to 60 times per second.
          Interpolation is required to get ICA2 transforms at HFR frame rate.
          This function calculates identical ICA2 transforms for each frame in the batch based on alignment transform.
          List of limitations on function call:
          One of the next: grid.enable or matrices.enable should be set to true, but not both.
          if matrices are enabled, only one matrix is supported for HFR.
*
*  @param [in]  batchedAlignmentTransform    Original ICA2 alignment matrix.
                                             Right now only the next alignment transforms are supported (but not together):
                                             a. one matrix
                                             b. grid
                                             It is expected that matrix is aligned to the center before calling this function.
                                             Please note that moving matrix to center and then calling to this function
                                             will return different result than calling to this function and then
                                             moving it to the center.
*  @param [in]  numOfFramesInBatch           Number of frames in the batch (It is expected to be more than one).
*  @param [out] hfrTransform                 The calculated HFR transform.
*                                            It is assumed that same transform structure is allocated for
                                             batchedAlignmentTransform and hfrTransform.
*
*  @return NC_LIB_SUCCESS in case of success, otherwise failed.
*/
int32_t NcLibGenerateHfr(
    const NcLibWarp* batchedAlignmentTransform,
    uint32_t numOfFramesInBatch,
    NcLibWarp* hfrTransform );

/**
*  @brief   The alignment transform for MCTF can be calculated by:
            1. Image-based alignment (LRME/CVP)
            2. Gyro based alignment
            Each option has its advantages and vulnerabilities.
            This function gets the results of both these two alignments
            and choose the best alignment transform.
*
*  @param [in]   in      Input struct
*  @param [out]  out     Output struct
*
*  @return NC_LIB_SUCCESS in case of success, otherwise failed.
*/
int32_t NcLibAlignmentFusion(
    const NcLibAlignmentFusionIn* in,
    NcLibAlignmentFusionOut* out);

/**
*  @brief   Translate faces coordinates from CVP post-ICA domain to still domain.
*
*  @param [in]   fdRois        Latest available faces data (current or previous frame).
*  @param [in]   roisNum       Number of detected faces (fdRois size).
*  @param [in]   fdDimensions  The CVP ICA out image dimensions.
*  @param [in]   warp          CVP ICA transform. Must be defined on virtual domain.
*  @param [in]   fullSize      Still input size (IFE in).
*  @param [out]  fdOutRois     Faces data in still domain.
*
*  @return NC_LIB_SUCCESS in case of success, otherwise failed.
*/
int32_t NcLibTranslateFdDomains(
    const NcLibRectangle* fdRois,
    uint32_t roisNum,
    const NcLibImageSize* fdDimensions,
    const NcLibWarp* warp,
    const NcLibImageSize* fullSize,
    NcLibRectangle* fdOutRois);

/**
*  @brief   Create WarpGrid struct that points to an existing IcaGrid buffer (shallow copy).
*
*  @param [in]   icaGrid       Original grid struct
*  @param [out]  warpGrid      Output grid struct. grid and gridExtrapolate will point to icaGrid buffers
*  @param [in]   ignoreErrors  Whether to continue if unsupported geometry is passed
*
*  @return true in case of success, false if error occured and ignoreErrors is true.
*/
bool NcLibIcaGridToWarpGridRef(const NcLibIcaGrid& icaGrid, NcLibWarpGrid& warpGrid, bool ignoreErrors = false);

/**
*  @brief   Copy grid meta data from WarpGrid to IcaGrid.
*
*  @param [in]   warpGrid      Original grid struct
*  @param [out]  icaGrid       Output grid struct. The following fields are not set: reuseGridTransform, grid, gridCorners.
*
*  @return true in case of success, false in case of error.
*/
bool NcLibWarpGridToIcaGridMeta(const NcLibWarpGrid& warpGrid, NcLibIcaGrid& icaGrid);
#define NcLibWarpGridTpIcaGridMeta(_warpGrid, _icaGrid)   NcLibWarpGridToIcaGridMeta(_warpGrid, _icaGrid)

/**
*  @brief   Copy WarpGrid to IcaGrid (deep copy).
*
*  @param [in]   warpGrid      Original grid struct
*  @param [out]  icaGrid       Output grid struct
*
*  @return true in case of success, false in case of error.
*/
bool NcLibWarpGridToIcaGrid(const NcLibWarpGrid& warpGrid, NcLibIcaGrid& icaGrid);
#define NcLibWarpGridTpIcaGrid(_warpGrid, _icaGrid)   NcLibWarpGridToIcaGrid(_warpGrid, _icaGrid)

/**
*  @brief   Copy IcaMatrices to WarpMatrices (deep copy).
*
*  @param [in]   icaMatrices       Original matrices struct
*  @param [out]  warpMatrices      Output matrices struct
*
*  @return true in case of success, false in case of error.
*/
bool NcLibIcaMatricesToWarpMatrices(const NcLibIcaMatrices& icaMatrices, NcLibWarpMatrices& warpMatrices);


#ifdef __cplusplus
}
#endif

#endif /* __NC_LIB_WARP_API__ */
